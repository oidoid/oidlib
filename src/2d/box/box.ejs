import { argsToBox, Box, BoxJSON, <% if (type != 'Num') { %><%- type %>, <% } %><% if (type == 'Num' || type == 'Unum') { %>Numerical<% } else { %>Integral<% } %>Box,<% if (type != 'Num') { %> NumBox, NumXY,<% } %> <%- type %>XY, XY } from '@/ooz'

export class <%- type %>Box implements <% if (type == 'Num' || type == 'Unum') { %>Numerical<% } else { %>Integral<% } %>Box<<%- component %>> {
  <% coercions.forEach(coerce =>{ %>
  static <%- coerce.toLowerCase() %>(x: number, y: number, w: number, h: number): <%- type %>Box
  static <%- coerce.toLowerCase() %>(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): <%- type %>Box
  static <%- coerce.toLowerCase() %>(box: Readonly<Box<number>>): <%- type %>Box
  static <%- coerce.toLowerCase() %>(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): <%- type %>Box {
    const box = argsToBox(xXYBox, yWH, w, h)
    return new this(<%- type %>XY.<%- coerce.toLowerCase() %>(box.x, box.y), <%- type %>XY.<%- coerce.toLowerCase() %>(box.w, box.h))
  }
  <% }) %>

  static fromJSON(json: Readonly<BoxJSON>): <%- type %>Box {
    return new this(
      json.xy?.x ?? json.x ?? 0,
      json.xy?.y ?? json.y ?? 0,
      json.wh?.x ?? json.w ?? 0,
      json.wh?.y ?? json.h ?? 0
    )
  }

  #xy: <%- type %>XY
  #wh: <%- type %>XY

  constructor(x: number, y: number, w: number, h: number)
  constructor(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>)
  constructor(box: Readonly<Box<number>>)
  constructor(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ) {
    const box = argsToBox(xXYBox, yWH, w, h)
    this.#xy = new <%- type %>XY(box.x, box.y)
    this.#wh = new <%- type %>XY(box.w, box.h)
  }

  get area(): <%- component %> {
    return this.#wh.area
  }

  get areaClamp(): <%- component %> {
    return this.#wh.areaClamp
  }

  get areaNum(): number {
    return this.#wh.areaNum
  }

  <% ['', ...coercions].forEach(coerce =>{ %>
  get center<%- coerce %>(): <%- type %>XY {
    return <% if (coerce == '') { %>new <% } %><%- type %>XY<% if (coerce != '') { %>.<%- coerce.toLowerCase() %><% } %>(this.centerNum)
  }
  <% }) %>

  get centerNum(): NumXY {
    return this.#wh.toNumXY().div(2, 2).add(this.#xy)
  }

  construct(x: number, y: number, w: number, h: number): this
  construct(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): this
  construct(box: Readonly<Box<number>>): this
  construct(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): this {
    return new <%- type %>Box(
      xXYBox as number,
      yWH as number,
      w as number,
      h as number,
    ) as this
  }

  <% coercions.forEach(coerce =>{ %>
  construct<%- coerce %>(x: number, y: number, w: number, h: number): this
  construct<%- coerce %>(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): this
  construct<%- coerce %>(box: Readonly<Box<number>>): this
  construct<%- coerce %>(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): this {
    return <%- type %>Box.<%- coerce.toLowerCase() %>(xXYBox as number, yWH as number, w as number, h as number) as this
  }
  <% }) %>

  contains(x: number, y: number): boolean
  contains(xy: Readonly<XY<number>>): boolean
  contains(x: number, y: number, w: number, h: number): boolean
  contains(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): boolean
  contains(box: Readonly<Box<number>>): boolean
  contains(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): boolean {
    if (this.empty) return false
    const box = argsToBox(xXYBox, yWH, w, h)
    return this.x <= box.x && (this.x + this.w) >= (box.x + box.w) &&
      this.y <= box.y && (this.y + this.h) >= (box.y + box.h)
  }

  copy(): this {
    return new <%- type %>Box(this.x, this.y, this.w, this.h) as this
  }

  get empty(): boolean {
    return this.areaNum == 0
  }

  get end(): <%- type %>XY {
    return new <%- type %>XY(this.endNum)
  }

  get endClamp(): <%- type %>XY {
    return <%- type %>XY.clamp(this.endNum)
  }

  get endNum(): NumXY {
    return this.#xy.toNumXY().add(this.#wh)
  }

  eq(x: number, y: number, w: number, h: number): boolean
  eq(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): boolean
  eq(box: Readonly<Box<number>>): boolean
  eq(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): boolean {
    const box = argsToBox(xXYBox, yWH, w, h)
    return this.x == box.x && this.y == box.y &&
      this.w == box.w && this.h == box.h
  }

  get flipped(): boolean {
    return this.w < 0 || this.h < 0
  }

  <% ['', ...coercions].forEach(coerce =>{ %>
  intersection<%- coerce %>(x: number, y: number, w: number, h: number): this
  intersection<%- coerce %>(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): this
  intersection<%- coerce %>(box: Readonly<Box<number>>): this
  intersection<%- coerce %>(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): this {
    const box = new NumBox(argsToBox(xXYBox, yWH, w, h))
    const xy = box.min.max(this.min)
    const wh = box.max.min(this.max).sub(xy)
    this.#xy.set<%- coerce %>(xy)
    this.#wh.set<%- coerce %>(wh)
    return this
  }
  <% }) %>

  intersects(x: number, y: number): boolean
  intersects(xy: Readonly<XY<number>>): boolean
  intersects(x: number, y: number, w: number, h: number): boolean
  intersects(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): boolean
  intersects(box: Readonly<Box<number>>): boolean
  intersects(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): boolean {
    const box = argsToBox(xXYBox, yWH, w, h)
    return this.x < (box.x + box.w) && (this.x + this.w) > box.x &&
      this.y < (box.y + box.h) && (this.y + this.h) > box.y
  }

  get max(): <%- type %>XY {
    return new <%- type %>XY(this.maxNum)
  }

  get maxClamp(): <%- type %>XY {
    return <%- type %>XY.clamp(this.maxNum)
  }

  get maxNum(): NumXY {
    return this.#xy.toNumXY().add(
      this.w > 0 ? this.w : 0,
      this.h > 0 ? this.h : 0,
    )
  }

  get min(): <%- type %>XY {
    return new <%- type %>XY(this.minNum)
  }

  get minClamp(): <%- type %>XY {
    return <%- type %>XY.clamp(this.minNum)
  }

  get minNum(): NumXY {
    return this.#xy.toNumXY().add(
      this.w < 0 ? this.w : 0,
      this.h < 0 ? this.h : 0,
    )
  }

  <% ['', ...coercions].forEach(coerce =>{ %>
  moveBy<%- coerce %>(x: number, y: number): this
  moveBy<%- coerce %>(xy: Readonly<XY<number>>): this
  moveBy<%- coerce %>(xXY: number | Readonly<XY<number>>, y?: number): this {
    this.#xy.set<%- coerce %>(
      this.x + (typeof xXY == 'number' ? xXY : xXY.x),
      this.y + (typeof xXY == 'number' ? y! : xXY.y)
    )
    return this
  }
  <% }) %>

  <% ['', ...coercions].forEach(coerce =>{ %>
  moveCenterTo<%- coerce %>(x: number, y: number): this
  moveCenterTo<%- coerce %>(xy: Readonly<XY<number>>): this
  moveCenterTo<%- coerce %>(xXY: number | Readonly<XY<number>>, y?: number): this {
    const center = this.#wh.toNumXY().div(2, 2)
    this.#xy.set<%- coerce %>(
      (typeof xXY == 'number' ? xXY : xXY.x) - center.x,
      (typeof xXY == 'number' ? y! : xXY.y) - center.y
    )
    return this
  }
  <% }) %>

  <% ['', ...coercions].forEach(coerce =>{ %>
  moveTo<%- coerce %>(x: number, y: number): this
  moveTo<%- coerce %>(xy: Readonly<XY<number>>): this
  moveTo<%- coerce %>(xXY: number | Readonly<XY<number>>, y?: number): this {
    this.#xy.set<%- coerce %>(
      (typeof xXY == 'number' ? xXY : xXY.x),
      (typeof xXY == 'number' ? y! : xXY.y)
    )
    return this
  }
  <% }) %>

  order(): this {
    const min = this.min
    return this.set(min, this.max.sub(min))
  }

  orderClamp(): this {
    const min = this.min
    return this.setClamp(min, this.max.sub(min))
  }

  <% ['', ...coercions].forEach(coerce =>{ %>
  set<%- coerce %>(x: number, y: number, w: number, h: number): this
  set<%- coerce %>(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): this
  set<%- coerce %>(box: Readonly<Box<number>>): this
  set<%- coerce %>(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): this {
    const box = argsToBox(xXYBox, yWH, w, h)
    this.#xy.set<%- coerce %>(box.x, box.y)
    this.#wh.set<%- coerce %>(box.w, box.h)
    return this
  }
  <% }) %>

  <% ['', ...coercions].forEach(coerce =>{ %>
  sizeBy<%- coerce %>(x: number, y: number): this
  sizeBy<%- coerce %>(xy: Readonly<XY<number>>): this
  sizeBy<%- coerce %>(xXY: number | Readonly<XY<number>>, y?: number): this {
    this.#wh.set<%- coerce %>(
      this.w + (typeof xXY == 'number' ? xXY : xXY.x),
      this.h + (typeof xXY == 'number' ? y! : xXY.y)
    )
    return this
  }
  <% }) %>

  <% ['', ...coercions].forEach(coerce =>{ %>
  sizeTo<%- coerce %>(x: number, y: number): this
  sizeTo<%- coerce %>(xy: Readonly<XY<number>>): this
  sizeTo<%- coerce %>(xXY: number | Readonly<XY<number>>, y?: number): this {
    this.#wh.set<%- coerce %>(
      (typeof xXY == 'number' ? xXY : xXY.x),
      (typeof xXY == 'number' ? y! : xXY.y)
    )
    return this
  }
  <% }) %>

    <% ['', ...coercions].forEach(coerce =>{ %>
  union<%- coerce %>(x: number, y: number, w: number, h: number): this
  union<%- coerce %>(xy: Readonly<XY<number>>, wh: Readonly<XY<number>>): this
  union<%- coerce %>(box: Readonly<Box<number>>): this
  union<%- coerce %>(
    xXYBox: number | Readonly<XY<number>> | Readonly<Box<number>>,
    yWH?: number | Readonly<XY<number>>,
    w?: number,
    h?: number,
  ): this {
    const box = new NumBox(argsToBox(xXYBox, yWH, w, h))
    const xy = box.min.min(this.min)
    const wh = box.max.max(this.max).sub(xy)
    this.#xy.set<%- coerce %>(xy)
    this.#wh.set<%- coerce %>(wh)
    return this
  }
  <% }) %>

  toJSON(): Partial<Box<<%- component %>>> {
    return {
      ...(this.x == 0 ? undefined : {x: this.x}),
      ...(this.y == 0 ? undefined : {y: this.y}),
      ...(this.w == 0 ? undefined : {w: this.w}),
      ...(this.h == 0 ? undefined : {h: this.h})
    }
  }

  toNumBox(): NumBox {
    return new NumBox(this.x, this.y, this.w, this.h)
  }

  toString(): string {
    return `[${this.#xy.toString()}, ${this.w}Ã—${this.h}]`
  }

  get x(): <%- component %> {
    return this.#xy.x
  }

  set x(x: <%- component %>) {
    this.#xy.x = x
  }

  get y(): <%- component %> {
    return this.#xy.y
  }

  set y(y: <%- component %>) {
    this.#xy.y = y
  }

  get xy(): <%- type %>XY {
    return this.#xy
  }

  get w(): <%- component %> {
    return this.#wh.x
  }

  set w(w: <%- component %>) {
    this.#wh.x = w
  }

  get h(): <%- component %> {
    return this.#wh.y
  }

  set h(h: <%- component %>) {
    this.#wh.y = h
  }

  get wh(): <%- type %>XY {
    return this.#wh
  }

  set wh(wh: <%- type %>XY) {
    this.w = wh.x
    this.h = wh.y
  }
}
