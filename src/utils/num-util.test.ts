import { Int, NumUtil } from '@/ooz'
import { assertEquals } from 'std/testing/asserts.ts'

Deno.test('wrap()', async (test) => {
  for (
    const [x, min, max, expected] of // deno-fmt-ignore
    [
      // Negative to zero range.
      [ -5  , -1,  0, -1  ],
      [ -4.5, -1,  0,  -.5],
      [ -4  , -1,  0, -1  ],
      [ -3.5, -1,  0,  -.5],
      [ -3  , -1,  0, -1  ],
      [ -2.5, -1,  0,  -.5],
      [ -2  , -1,  0, -1  ],
      [ -1.5, -1,  0,  -.5],
      [ -1  , -1,  0, -1  ],
      [  -.5, -1,  0,  -.5],
      [  0  , -1,  0, -1  ],
      [   .5, -1,  0,  -.5],
      [  1  , -1,  0, -1  ],
      [  1.5, -1,  0,  -.5],
      [  2  , -1,  0, -1  ],
      [  2.5, -1,  0,  -.5],
      [  3  , -1,  0, -1  ],
      [  3.5, -1,  0,  -.5],
      [  4  , -1,  0, -1  ],
      [  4.5, -1,  0,  -.5],
      [  5  , -1,  0, -1  ],
  
      // Zero to positive range.
      [ -5  ,  0,  1,  0  ],
      [ -4.5,  0,  1,   .5],
      [ -4  ,  0,  1,  0  ],
      [ -3.5,  0,  1,   .5],
      [ -3  ,  0,  1,  0  ],
      [ -2.5,  0,  1,   .5],
      [ -2  ,  0,  1,  0  ],
      [ -1.5,  0,  1,   .5],
      [ -1  ,  0,  1,  0  ],
      [  -.5,  0,  1,   .5],
      [  0  ,  0,  1,  0  ],
      [   .5,  0,  1,   .5],
      [  1  ,  0,  1,  0  ],
      [  1.5,  0,  1,   .5],
      [  2  ,  0,  1,  0  ],
      [  2.5,  0,  1,   .5],
      [  3  ,  0,  1,  0  ],
      [  3.5,  0,  1,   .5],
      [  4  ,  0,  1,  0  ],
      [  4.5,  0,  1,   .5],
      [  5  ,  0,  1,  0  ],
  
      // Negative to positive range.
      [ -5  , -1,  1, -1  ],
      [ -4.5, -1,  1,  -.5],
      [ -4  , -1,  1,  0  ],
      [ -3.5, -1,  1,   .5],
      [ -3  , -1,  1, -1  ],
      [ -2.5, -1,  1,  -.5],
      [ -2  , -1,  1,  0  ],
      [ -1.5, -1,  1,   .5],
      [ -1  , -1,  1, -1  ],
      [  -.5, -1,  1,  -.5],
      [  0  , -1,  1,  0  ],
      [   .5, -1,  1,   .5],
      [  1  , -1,  1, -1  ],
      [  1.5, -1,  1,  -.5],
      [  2  , -1,  1,  0  ],
      [  2.5, -1,  1,   .5],
      [  3  , -1,  1, -1  ],
      [  3.5, -1,  1,  -.5],
      [  4  , -1,  1,  0  ],
      [  4.5, -1,  1,   .5],
      [  5  , -1,  1, -1  ],
  
      // Lesser negative range.
      [ -7  , -6, -4, -5  ],
      [ -6.5, -6, -4, -4.5],
      [ -6  , -6, -4, -6  ],
      [ -5.5, -6, -4, -5.5],
      [ -5  , -6, -4, -5  ],
      [ -4.5, -6, -4, -4.5],
      [ -4  , -6, -4, -6  ],
      [ -3.5, -6, -4, -5.5],
      [ -3  , -6, -4, -5  ],
      [ -2.5, -6, -4, -4.5],
      [ -2  , -6, -4, -6  ],
      [ -1.5, -6, -4, -5.5],
      [ -1  , -6, -4, -5  ],
      [  -.5, -6, -4, -4.5],
      [  0  , -6, -4, -6  ],
      [   .5, -6, -4, -5.5],
      [  1  , -6, -4, -5  ],
      [  1.5, -6, -4, -4.5],
      [  2  , -6, -4, -6  ],
      [  2.5, -6, -4, -5.5],
      [  3  , -6, -4, -5  ],
      [  3.5, -6, -4, -4.5],
      [  4  , -6, -4, -6  ],
      [  4.5, -6, -4, -5.5],
      [  5  , -6, -4, -5  ],
      [  5.5, -6, -4, -4.5],
      [  6  , -6, -4, -6  ],
      [  6.5, -6, -4, -5.5],
      [  7  , -6, -4, -5  ],
  
      // Negative range.
      [-10  , -3, -1, -2  ],
      [ -9.5, -3, -1, -1.5],
      [ -9  , -3, -1, -3  ],
      [ -8.5, -3, -1, -2.5],
      [ -8  , -3, -1, -2  ],
      [ -7.5, -3, -1, -1.5],
      [ -7  , -3, -1, -3  ],
      [ -6.5, -3, -1, -2.5],
      [ -6  , -3, -1, -2  ],
      [ -5.5, -3, -1, -1.5],
      [ -5  , -3, -1, -3  ],
      [ -4.5, -3, -1, -2.5],
      [ -4  , -3, -1, -2  ],
      [ -3.5, -3, -1, -1.5],
      [ -3  , -3, -1, -3  ],
      [ -2.5, -3, -1, -2.5],
      [ -2  , -3, -1, -2  ],
      [ -1.5, -3, -1, -1.5],
      [ -1  , -3, -1, -3  ],
      [  -.5, -3, -1, -2.5],
      [  0  , -3, -1, -2  ],
      [   .5, -3, -1, -1.5],
      [  1  , -3, -1, -3  ],
      [  1.5, -3, -1, -2.5],
      [  2  , -3, -1, -2  ],
      [  2.5, -3, -1, -1.5],
      [  3  , -3, -1, -3  ],
      [  3.5, -3, -1, -2.5],
      [  4  , -3, -1, -2  ],
      [  4.5, -3, -1, -1.5],
      [  5  , -3, -1, -3  ],
  
      // Positive range.
      [ -5  ,  1,  3,  1  ],
      [ -4.5,  1,  3,  1.5],
      [ -4  ,  1,  3,  2  ],
      [ -3.5,  1,  3,  2.5],
      [ -3  ,  1,  3,  1  ],
      [ -2.5,  1,  3,  1.5],
      [ -2  ,  1,  3,  2  ],
      [ -1.5,  1,  3,  2.5],
      [ -1  ,  1,  3,  1  ],
      [  -.5,  1,  3,  1.5],
      [  0  ,  1,  3,  2  ],
      [   .5,  1,  3,  2.5],
      [  1  ,  1,  3,  1  ],
      [  1.5,  1,  3,  1.5],
      [  2  ,  1,  3,  2  ],
      [  2.5,  1,  3,  2.5],
      [  3  ,  1,  3,  1  ],
      [  3.5,  1,  3,  1.5],
      [  4  ,  1,  3,  2  ],
      [  4.5,  1,  3,  2.5],
      [  5  ,  1,  3,  1  ],
  
      // Greater positive range.
      [ -7  ,  4,  6,  5  ],
      [ -6.5,  4,  6,  5.5],
      [ -6  ,  4,  6,  4  ],
      [ -5.5,  4,  6,  4.5],
      [ -5  ,  4,  6,  5  ],
      [ -4.5,  4,  6,  5.5],
      [ -4  ,  4,  6,  4  ],
      [ -3.5,  4,  6,  4.5],
      [ -3  ,  4,  6,  5  ],
      [ -2.5,  4,  6,  5.5],
      [ -2  ,  4,  6,  4  ],
      [ -1.5,  4,  6,  4.5],
      [ -1  ,  4,  6,  5  ],
      [  -.5,  4,  6,  5.5],
      [  0  ,  4,  6,  4  ],
      [   .5,  4,  6,  4.5],
      [  1  ,  4,  6,  5  ],
      [  1.5,  4,  6,  5.5],
      [  2  ,  4,  6,  4  ],
      [  2.5,  4,  6,  4.5],
      [  3  ,  4,  6,  5  ],
      [  3.5,  4,  6,  5.5],
      [  4  ,  4,  6,  4  ],
      [  4.5,  4,  6,  4.5],
      [  5  ,  4,  6,  5  ],
      [  5.5,  4,  6,  5.5],
      [  6  ,  4,  6,  4  ],
      [  6.5,  4,  6,  4.5],
      [  7  ,  4,  6,  5  ],
  
      // Even greater positive range.
      [ 88  ,  90,  95, 93  ],
      [ 88.5,  90,  95, 93.5],
      [ 89  ,  90,  95, 94  ],
      [ 89.5,  90,  95, 94.5],
      [ 90  ,  90,  95, 90  ],
      [ 90.5,  90,  95, 90.5],
      [ 91  ,  90,  95, 91  ],
      [ 91.5,  90,  95, 91.5],
      [ 92  ,  90,  95, 92  ],
      [ 92.5,  90,  95, 92.5],
      [ 93  ,  90,  95, 93  ],
      [ 93.5,  90,  95, 93.5],
      [ 94  ,  90,  95, 94  ],
      [ 94.5,  90,  95, 94.5],
      [ 95  ,  90,  95, 90  ],
      [ 95.5,  90,  95, 90.5],
      [ 96  ,  90,  95, 91  ],
      [ 96.5,  90,  95, 91.5],
      [ 97  ,  90,  95, 92  ],
      [ 97.5,  90,  95, 92.5],
      [ 98  ,  90,  95, 93  ],
      [ 98.5,  90,  95, 93.5],
      [ 99  ,  90,  95, 94  ],
      [ 99.5,  90,  95, 94.5],
  
      // Negative to positive range with many inputs.
      [-20  , -3,  3, -2  ],
      [-19.5, -3,  3, -1.5],
      [-19  , -3,  3, -1  ],
      [-18.5, -3,  3,  -.5],
      [-18  , -3,  3,  0  ],
      [-17.5, -3,  3,   .5],
      [-17  , -3,  3,  1  ],
      [-16.5, -3,  3,  1.5],
      [-16  , -3,  3,  2  ],
      [-15.5, -3,  3,  2.5],
      [-15  , -3,  3, -3  ],
      [-14.5, -3,  3, -2.5],
      [-14  , -3,  3, -2  ],
      [-13.5, -3,  3, -1.5],
      [-13  , -3,  3, -1  ],
      [-12.5, -3,  3,  -.5],
      [-12  , -3,  3,  0  ],
      [-11.5, -3,  3,   .5],
      [-11  , -3,  3,  1  ],
      [-10.5, -3,  3,  1.5],
      [-10  , -3,  3,  2  ],
      [ -9.5, -3,  3,  2.5],
      [ -9  , -3,  3, -3  ],
      [ -8.5, -3,  3, -2.5],
      [ -8  , -3,  3, -2  ],
      [ -7.5, -3,  3, -1.5],
      [ -7  , -3,  3, -1  ],
      [ -6.5, -3,  3,  -.5],
      [ -6  , -3,  3,  0  ],
      [ -5.5, -3,  3,   .5],
      [ -5  , -3,  3,  1  ],
      [ -4.5, -3,  3,  1.5],
      [ -4  , -3,  3,  2  ],
      [ -3.5, -3,  3,  2.5],
      [ -3  , -3,  3, -3  ],
      [ -2.5, -3,  3, -2.5],
      [ -2  , -3,  3, -2  ],
      [ -1.5, -3,  3, -1.5],
      [ -1  , -3,  3, -1  ],
      [  -.5, -3,  3,  -.5],
      [  0  , -3,  3,  0  ],
      [   .5, -3,  3,   .5],
      [  1  , -3,  3,  1  ],
      [  1.5, -3,  3,  1.5],
      [  2  , -3,  3,  2  ],
      [  2.5, -3,  3,  2.5],
      [  3  , -3,  3, -3  ],
      [  3.5, -3,  3, -2.5],
      [  4  , -3,  3, -2  ],
      [  4.5, -3,  3, -1.5],
      [  5  , -3,  3, -1  ],
      [  5.5, -3,  3,  -.5],
      [  6  , -3,  3,  0  ],
      [  6.5, -3,  3,   .5],
      [  7  , -3,  3,  1  ],
      [  7.5, -3,  3,  1.5],
      [  8  , -3,  3,  2  ],
      [  8.5, -3,  3,  2.5],
      [  9  , -3,  3, -3  ],
      [  9.5, -3,  3, -2.5],
      [ 10  , -3,  3, -2  ],
      [ 10.5, -3,  3, -1.5],
      [ 11  , -3,  3, -1  ],
      [ 11.5, -3,  3,  -.5],
      [ 12  , -3,  3,  0  ],
      [ 12.5, -3,  3,   .5],
      [ 13  , -3,  3,  1  ],
      [ 13.5, -3,  3,  1.5],
      [ 14  , -3,  3,  2  ],
      [ 14.5, -3,  3,  2.5],
      [ 15  , -3,  3, -3  ],
      [ 15.5, -3,  3, -2.5],
      [ 16  , -3,  3, -2  ],
      [ 16.5, -3,  3, -1.5],
      [ 17  , -3,  3, -1  ],
      [ 17.5, -3,  3,  -.5],
      [ 18  , -3,  3,  0  ],
      [ 18.5, -3,  3,   .5],
      [ 19  , -3,  3,  1  ],
      [ 19.5, -3,  3,  1.5],
      [ 20  , -3,  3,  2  ]
    ] as const
  ) {
    await test.step(`Wrap ${x} to [${min}, ${max}].`, () =>
      assertEquals(NumUtil.wrap(x, min, max), expected))
  }
})

Deno.test('lerpInt()', async (test) => {
  for (
    const [from, to, ratio, expected] of // deno-fmt-ignore
    [
      // Negative to.
      [-5, -10, 0.1,  -6],
      [-1, -10, 0.1,  -2],
      [ 1, -10, 0.1,   0],
      [ 5, -10, 0.1,   4],
      [10, -10, 0.1,   8],
      [11, -10, 0.1,   9],
      [15, -10, 0.1,  13],
      [-5, -10, 1,   -10],
      [-1, -10, 1,   -10],
      [ 1, -10, 1,   -10],
      [ 5, -10, 1,   -10],
      [10, -10, 1,   -10],
      [11, -10, 1,   -10],
      [15, -10, 1,   -10],
      [-5, -10, 0,    -5],
      [-1, -10, 0,    -1],
      [ 1, -10, 0,     1],
      [ 5, -10, 0,     5],
      [10, -10, 0,    10],
      [11, -10, 0,    11],
      [15, -10, 0,    15],
  
      // Zero to.
      [-5,   0, 0.1,  -4],
      [-1,   0, 0.1,   0],
      [ 0,   0, 0.1,   0],
      [ 1,   0, 0.1,   0],
      [ 5,   0, 0.1,   4],
      [-5,   0, 1  ,   0],
      [-1,   0, 1  ,   0],
      [ 0,   0, 1  ,   0],
      [ 1,   0, 1  ,   0],
      [ 5,   0, 1  ,   0],
      [-5,   0, 0  ,  -5],
      [-1,   0, 0  ,  -1],
      [ 0,   0, 0  ,   0],
      [ 1,   0, 0  ,   1],
      [ 5,   0, 0  ,   5],
  
      // Positive to.
      [-5,  10, 0.1,  -4],
      [-1,  10, 0.1,   0],
      [ 1,  10, 0.1,   2],
      [ 5,  10, 0.1,   6],
      [10,  10, 0.1,  10],
      [11,  10, 0.1,  10],
      [15,  10, 0.1,  14],
      [-5,  10, 1  ,  10],
      [-1,  10, 1  ,  10],
      [ 1,  10, 1  ,  10],
      [ 5,  10, 1  ,  10],
      [10,  10, 1  ,  10],
      [11,  10, 1  ,  10],
      [15,  10, 1  ,  10],
      [-5,  10, 0  ,  -5],
      [-1,  10, 0  ,  -1],
      [ 1,  10, 0  ,   1],
      [ 5,  10, 0  ,   5],
      [10,  10, 0  ,  10],
      [11,  10, 0  ,  11],
      [15,  10, 0  ,  15],
    ] as const
  ) {
    await test.step(`lerpInt(${from}, ${to}, ${ratio}) => ${expected}`, () =>
      assertEquals(
        NumUtil.lerpInt(Int(from), Int(to), ratio),
        Int(expected),
      ))
  }
})

Deno.test('round()', async (test) => {
  for (
    const [num, expected] of [
      [-3.0, -3],
      [-2.9, -3],
      [-2.8, -3],
      [-2.7, -3],
      [-2.6, -3],
      [-2.5, -3],
      [-2.4, -2],
      [-2.3, -2],
      [-2.2, -2],
      [-2.1, -2],
      [-2.0, -2],
      [-1.9, -2],
      [-1.8, -2],
      [-1.7, -2],
      [-1.6, -2],
      [-1.5, -2],
      [-1.4, -1],
      [-1.3, -1],
      [-1.2, -1],
      [-1.1, -1],
      [-1.0, -1],
      [-0.9, -1],
      [-0.8, -1],
      [-0.7, -1],
      [-0.6, -1],
      [-0.5, -1],
      [-0.4, 0],
      [-0.3, 0],
      [-0.2, 0],
      [-0.1, 0],
      [0.0, 0],
      [0.1, 0],
      [0.2, 0],
      [0.3, 0],
      [0.4, 0],
      [0.5, 1],
      [0.6, 1],
      [0.7, 1],
      [0.8, 1],
      [0.9, 1],
      [1.0, 1],
      [1.1, 1],
      [1.2, 1],
      [1.3, 1],
      [1.4, 1],
      [1.5, 2],
      [1.6, 2],
      [1.7, 2],
      [1.8, 2],
      [1.9, 2],
      [2.0, 2],
      [2.1, 2],
      [2.2, 2],
      [2.3, 2],
      [2.4, 2],
      [2.5, 3],
      [2.6, 3],
      [2.7, 3],
      [2.8, 3],
      [2.9, 3],
      [3.0, 3],
    ] as const
  ) {
    await test.step(`round(${num}) => ${expected}`, () =>
      assertEquals(NumUtil.round(num), Int(expected)))
  }
})

Deno.test('lshift()', async (test) => {
  for (
    const [shift, expected] of [
      0x00_00_00_00_00_00_01n,
      0x00_00_00_00_00_00_02n,
      0x00_00_00_00_00_00_04n,
      0x00_00_00_00_00_00_08n,
      0x00_00_00_00_00_00_10n,
      0x00_00_00_00_00_00_20n,
      0x00_00_00_00_00_00_40n,
      0x00_00_00_00_00_00_80n,
      0x00_00_00_00_00_01_00n,
      0x00_00_00_00_00_02_00n,
      0x00_00_00_00_00_04_00n,
      0x00_00_00_00_00_08_00n,
      0x00_00_00_00_00_10_00n,
      0x00_00_00_00_00_20_00n,
      0x00_00_00_00_00_40_00n,
      0x00_00_00_00_00_80_00n,
      0x00_00_00_00_01_00_00n,
      0x00_00_00_00_02_00_00n,
      0x00_00_00_00_04_00_00n,
      0x00_00_00_00_08_00_00n,
      0x00_00_00_00_10_00_00n,
      0x00_00_00_00_20_00_00n,
      0x00_00_00_00_40_00_00n,
      0x00_00_00_00_80_00_00n,
      0x00_00_00_01_00_00_00n,
      0x00_00_00_02_00_00_00n,
      0x00_00_00_04_00_00_00n,
      0x00_00_00_08_00_00_00n,
      0x00_00_00_10_00_00_00n,
      0x00_00_00_20_00_00_00n,
      0x00_00_00_40_00_00_00n,
      0x00_00_00_80_00_00_00n,
      0x00_00_01_00_00_00_00n,
      0x00_00_02_00_00_00_00n,
      0x00_00_04_00_00_00_00n,
      0x00_00_08_00_00_00_00n,
      0x00_00_10_00_00_00_00n,
      0x00_00_20_00_00_00_00n,
      0x00_00_40_00_00_00_00n,
      0x00_00_80_00_00_00_00n,
      0x00_01_00_00_00_00_00n,
      0x00_02_00_00_00_00_00n,
      0x00_04_00_00_00_00_00n,
      0x00_08_00_00_00_00_00n,
      0x00_10_00_00_00_00_00n,
      0x00_20_00_00_00_00_00n,
      0x00_40_00_00_00_00_00n,
      0x00_80_00_00_00_00_00n,
      0x01_00_00_00_00_00_00n,
      0x02_00_00_00_00_00_00n,
      0x04_00_00_00_00_00_00n,
      0x08_00_00_00_00_00_00n,
      0x10_00_00_00_00_00_00n,
      0x20_00_00_00_00_00_00n,
    ].entries()
  ) {
    const input = 1
    // There are no enforced limits so allow doubling at the 54th bit.
    const expectedNum = Number(BigInt.asUintN(54, expected))
    await test.step(`1 << ${shift} → x${expectedNum.toString(16)}`, () =>
      assertEquals(NumUtil.lshift(input, shift), expectedNum))
  }
})

Deno.test('unsigned right-shift', async (test) => {
  for (
    const [shift, expected] of [
      0x10_00_00_00_00_00_00n,
      0x08_00_00_00_00_00_00n,
      0x04_00_00_00_00_00_00n,
      0x02_00_00_00_00_00_00n,
      0x01_00_00_00_00_00_00n,
      0x00_80_00_00_00_00_00n,
      0x00_40_00_00_00_00_00n,
      0x00_20_00_00_00_00_00n,
      0x00_10_00_00_00_00_00n,
      0x00_08_00_00_00_00_00n,
      0x00_04_00_00_00_00_00n,
      0x00_02_00_00_00_00_00n,
      0x00_01_00_00_00_00_00n,
      0x00_00_80_00_00_00_00n,
      0x00_00_40_00_00_00_00n,
      0x00_00_20_00_00_00_00n,
      0x00_00_10_00_00_00_00n,
      0x00_00_08_00_00_00_00n,
      0x00_00_04_00_00_00_00n,
      0x00_00_02_00_00_00_00n,
      0x00_00_01_00_00_00_00n,
      0x00_00_00_80_00_00_00n,
      0x00_00_00_40_00_00_00n,
      0x00_00_00_20_00_00_00n,
      0x00_00_00_10_00_00_00n,
      0x00_00_00_08_00_00_00n,
      0x00_00_00_04_00_00_00n,
      0x00_00_00_02_00_00_00n,
      0x00_00_00_01_00_00_00n,
      0x00_00_00_00_80_00_00n,
      0x00_00_00_00_40_00_00n,
      0x00_00_00_00_20_00_00n,
      0x00_00_00_00_10_00_00n,
      0x00_00_00_00_08_00_00n,
      0x00_00_00_00_04_00_00n,
      0x00_00_00_00_02_00_00n,
      0x00_00_00_00_01_00_00n,
      0x00_00_00_00_00_80_00n,
      0x00_00_00_00_00_40_00n,
      0x00_00_00_00_00_20_00n,
      0x00_00_00_00_00_10_00n,
      0x00_00_00_00_00_08_00n,
      0x00_00_00_00_00_04_00n,
      0x00_00_00_00_00_02_00n,
      0x00_00_00_00_00_01_00n,
      0x00_00_00_00_00_00_80n,
      0x00_00_00_00_00_00_40n,
      0x00_00_00_00_00_00_20n,
      0x00_00_00_00_00_00_10n,
      0x00_00_00_00_00_00_08n,
      0x00_00_00_00_00_00_04n,
      0x00_00_00_00_00_00_02n,
      0x00_00_00_00_00_00_01n,
      0x00_00_00_00_00_00_00n,
      0x00_00_00_00_00_00_00n,
    ].entries()
  ) {
    const input = Number(BigInt.asUintN(53, 0x10_00_00_00_00_00_00n))
    const expectedNum = Number(BigInt.asUintN(53, expected))
    await test.step(`rshift x${input.toString(16)} >> ${shift} → x${expectedNum.toString(16)}`, () =>
      assertEquals(NumUtil.rshift(input, shift), expectedNum))
    await test.step(`ushift x${input.toString(16)} >> ${shift} → x${expectedNum.toString(16)}`, () =>
      assertEquals(NumUtil.ushift(input, shift), expectedNum))
  }
})

Deno.test('signed right-shift', async (test) => {
  for (
    const [shift, [expectedSigned, expectedUnsigned]] of ([
      [0x20_00_00_00_00_00_00n, 0x20_00_00_00_00_00_00n],
      [0x30_00_00_00_00_00_00n, 0x10_00_00_00_00_00_00n],
      [0x38_00_00_00_00_00_00n, 0x08_00_00_00_00_00_00n],
      [0x3c_00_00_00_00_00_00n, 0x04_00_00_00_00_00_00n],
      [0x3e_00_00_00_00_00_00n, 0x02_00_00_00_00_00_00n],
      [0x3f_00_00_00_00_00_00n, 0x01_00_00_00_00_00_00n],
      [0x3f_80_00_00_00_00_00n, 0x00_80_00_00_00_00_00n],
      [0x3f_c0_00_00_00_00_00n, 0x00_40_00_00_00_00_00n],
      [0x3f_e0_00_00_00_00_00n, 0x00_20_00_00_00_00_00n],
      [0x3f_f0_00_00_00_00_00n, 0x00_10_00_00_00_00_00n],
      [0x3f_f8_00_00_00_00_00n, 0x00_08_00_00_00_00_00n],
      [0x3f_fc_00_00_00_00_00n, 0x00_04_00_00_00_00_00n],
      [0x3f_fe_00_00_00_00_00n, 0x00_02_00_00_00_00_00n],
      [0x3f_ff_00_00_00_00_00n, 0x00_01_00_00_00_00_00n],
      [0x3f_ff_80_00_00_00_00n, 0x00_00_80_00_00_00_00n],
      [0x3f_ff_c0_00_00_00_00n, 0x00_00_40_00_00_00_00n],
      [0x3f_ff_e0_00_00_00_00n, 0x00_00_20_00_00_00_00n],
      [0x3f_ff_f0_00_00_00_00n, 0x00_00_10_00_00_00_00n],
      [0x3f_ff_f8_00_00_00_00n, 0x00_00_08_00_00_00_00n],
      [0x3f_ff_fc_00_00_00_00n, 0x00_00_04_00_00_00_00n],
      [0x3f_ff_fe_00_00_00_00n, 0x00_00_02_00_00_00_00n],
      [0x3f_ff_ff_00_00_00_00n, 0x00_00_01_00_00_00_00n],
      [0x3f_ff_ff_80_00_00_00n, 0x00_00_00_80_00_00_00n],
      [0x3f_ff_ff_c0_00_00_00n, 0x00_00_00_40_00_00_00n],
      [0x3f_ff_ff_e0_00_00_00n, 0x00_00_00_20_00_00_00n],
      [0x3f_ff_ff_f0_00_00_00n, 0x00_00_00_10_00_00_00n],
      [0x3f_ff_ff_f8_00_00_00n, 0x00_00_00_08_00_00_00n],
      [0x3f_ff_ff_fc_00_00_00n, 0x00_00_00_04_00_00_00n],
      [0x3f_ff_ff_fe_00_00_00n, 0x00_00_00_02_00_00_00n],
      [0x3f_ff_ff_ff_00_00_00n, 0x00_00_00_01_00_00_00n],
      [0x3f_ff_ff_ff_80_00_00n, 0x00_00_00_00_80_00_00n],
      [0x3f_ff_ff_ff_c0_00_00n, 0x00_00_00_00_40_00_00n],
      [0x3f_ff_ff_ff_e0_00_00n, 0x00_00_00_00_20_00_00n],
      [0x3f_ff_ff_ff_f0_00_00n, 0x00_00_00_00_10_00_00n],
      [0x3f_ff_ff_ff_f8_00_00n, 0x00_00_00_00_08_00_00n],
      [0x3f_ff_ff_ff_fc_00_00n, 0x00_00_00_00_04_00_00n],
      [0x3f_ff_ff_ff_fe_00_00n, 0x00_00_00_00_02_00_00n],
      [0x3f_ff_ff_ff_ff_00_00n, 0x00_00_00_00_01_00_00n],
      [0x3f_ff_ff_ff_ff_80_00n, 0x00_00_00_00_00_80_00n],
      [0x3f_ff_ff_ff_ff_c0_00n, 0x00_00_00_00_00_40_00n],
      [0x3f_ff_ff_ff_ff_e0_00n, 0x00_00_00_00_00_20_00n],
      [0x3f_ff_ff_ff_ff_f0_00n, 0x00_00_00_00_00_10_00n],
      [0x3f_ff_ff_ff_ff_f8_00n, 0x00_00_00_00_00_08_00n],
      [0x3f_ff_ff_ff_ff_fc_00n, 0x00_00_00_00_00_04_00n],
      [0x3f_ff_ff_ff_ff_fe_00n, 0x00_00_00_00_00_02_00n],
      [0x3f_ff_ff_ff_ff_ff_00n, 0x00_00_00_00_00_01_00n],
      [0x3f_ff_ff_ff_ff_ff_80n, 0x00_00_00_00_00_00_80n],
      [0x3f_ff_ff_ff_ff_ff_c0n, 0x00_00_00_00_00_00_40n],
      [0x3f_ff_ff_ff_ff_ff_e0n, 0x00_00_00_00_00_00_20n],
      [0x3f_ff_ff_ff_ff_ff_f0n, 0x00_00_00_00_00_00_10n],
      [0x3f_ff_ff_ff_ff_ff_f8n, 0x00_00_00_00_00_00_08n],
      [0x3f_ff_ff_ff_ff_ff_fcn, 0x00_00_00_00_00_00_04n],
      [0x3f_ff_ff_ff_ff_ff_fen, 0x00_00_00_00_00_00_02n],
      [0x3f_ff_ff_ff_ff_ff_ffn, 0x00_00_00_00_00_00_01n],
      [0x3f_ff_ff_ff_ff_ff_ffn, 0x00_00_00_00_00_00_00n],
      [0x3f_ff_ff_ff_ff_ff_ffn, 0x00_00_00_00_00_00_00n],
    ] as const).entries()
  ) {
    const input = Number(BigInt.asIntN(54, 0x20_00_00_00_00_00_00n))
    const expectedSignedNum = Number(BigInt.asIntN(54, expectedSigned))
    const expectedUnsignedNum = Number(BigInt.asUintN(54, expectedUnsigned))
    await test.step(`rshift x${input.toString(16)} >> ${shift} → x${expectedSignedNum.toString(16)} (x${Number(BigInt.asUintN(54, expectedSigned)).toString(16)})`, () =>
      assertEquals(NumUtil.rshift(input, shift), expectedSignedNum))
    await test.step(`ushift x${input.toString(16)} >> ${shift} → x${expectedUnsignedNum.toString(16)}`, () =>
      assertEquals(NumUtil.ushift(input, shift), expectedUnsignedNum))
  }
})

Deno.test('mod int', async (test) => {
  for (
    const [index, [input, expectedInt, expectedUint]] of // deno-fmt-ignore
    ([
      [Number.MIN_SAFE_INTEGER - 1, BigInt(Number.MIN_SAFE_INTEGER - 1), 0x00_00_00_00_00_00_00n],
      [Number.MIN_SAFE_INTEGER, BigInt(Number.MIN_SAFE_INTEGER), 0x00_00_00_00_00_00_01n],
      [Number.MIN_SAFE_INTEGER + 1, BigInt(Number.MIN_SAFE_INTEGER + 1), 0x00_00_00_00_00_00_02n],
      [Number.MAX_SAFE_INTEGER - 1, BigInt(Number.MAX_SAFE_INTEGER - 1), BigInt(Number.MAX_SAFE_INTEGER - 1)],
      [Number.MAX_SAFE_INTEGER, BigInt(Number.MAX_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER)],
      [Number.MAX_SAFE_INTEGER + 1, BigInt(Number.MIN_SAFE_INTEGER - 1), 0n],
    ] as const).entries()
  ) {
    const expectedIntNum = Number(BigInt.asIntN(54, expectedInt))
    const expectedUintNum = Number(BigInt.asUintN(54, expectedUint))
    await test.step(`${index} modInt(x${input.toString(16)}) → x${expectedIntNum.toString(16)} (x${Number(BigInt.asUintN(53, expectedInt)).toString(16)})`, () =>
      assertEquals(NumUtil.modInt(input), expectedIntNum))
    await test.step(`${index} modUint(x${input.toString(16)}) → x${expectedUintNum.toString(16)} (x${Number(BigInt.asUintN(53, expectedUint)).toString(16)})`, () =>
      assertEquals(NumUtil.modUint(input), expectedUintNum))
  }
})
